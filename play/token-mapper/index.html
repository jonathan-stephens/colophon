<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSS Variable Inheritance Mapper</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; font-family: system-ui, -apple-system, sans-serif; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect } = React;

        const DEPTH_COLORS = ['#E40303', '#FF8C00', '#FFED00', '#008026', '#24408E', '#732982', '#5BCEFA', '#F5A9B8', '#FFFFFF', '#000000'];

        const EXAMPLE_CSS = `:root {
  --blue-500: #3b82f6;
  --blue-600: #2563eb;
  --gray-100: #f3f4f6;
  --gray-900: #111827;
  --space-1: 4px;
  --space-2: 8px;
  --color-primary: var(--blue-600);
  --color-text: var(--gray-900);
  --button-bg: var(--color-primary);
  --button-padding: var(--space-2);
}`;

        function parseCSS(cssText) {
            const tokens = new Map();
            const varRegex = /--([^:]+):\s*([^;]+);/g;
            let match;

            while ((match = varRegex.exec(cssText)) !== null) {
                const name = `--${match[1].trim()}`;
                const value = match[2].trim();
                const refs = [];
                const refRegex = /var\(--([^)]+)\)/g;
                let refMatch;
                while ((refMatch = refRegex.exec(value)) !== null) {
                    refs.push(`--${refMatch[1].trim()}`);
                }
                
                let type = 'other';
                if (name.includes('color') || name.includes('blue') || name.includes('gray') || name.includes('bg')) type = 'color';
                else if (name.includes('space') || name.includes('padding')) type = 'spacing';
                else if (name.includes('font') || name.includes('text')) type = 'typography';
                
                tokens.set(name, { name, value, refs, type, depth: 0 });
            }
            
            const calculateDepth = (name, visited = new Set()) => {
                if (visited.has(name)) return 0;
                visited.add(name);
                const token = tokens.get(name);
                if (!token || token.refs.length === 0) return 0;
                const maxDepth = Math.max(...token.refs.map(ref => calculateDepth(ref, new Set(visited))));
                token.depth = maxDepth + 1;
                return token.depth;
            };
            
            tokens.forEach((_, name) => calculateDepth(name));
            return Array.from(tokens.values());
        }

        function TreeView({ tokens, onNodeClick, highlightedNode, filter }) {
            const [transform, setTransform] = useState({ x: 0, y: 0, scale: 1 });
            const [isDragging, setIsDragging] = useState(false);
            const [dragStart, setDragStart] = useState({ x: 0, y: 0 });

            const filteredTokens = tokens.filter(t => !filter || t.type === filter);
            const byDepth = {};
            filteredTokens.forEach(token => {
                if (!byDepth[token.depth]) byDepth[token.depth] = [];
                byDepth[token.depth].push(token);
            });
            
            const nodes = filteredTokens.map((token) => {
                const depthNodes = byDepth[token.depth];
                const indexInDepth = depthNodes.indexOf(token);
                return { ...token, x: token.depth * 250 + 50, y: indexInDepth * 80 + 50 };
            });
            
            const edges = [];
            nodes.forEach(node => {
                node.refs.forEach(refName => {
                    const target = nodes.find(n => n.name === refName);
                    if (target) edges.push({ source: node, target });
                });
            });

            const isHighlighted = (node) => {
                if (!highlightedNode) return true;
                if (node.name === highlightedNode) return true;
                const highlighted = nodes.find(n => n.name === highlightedNode);
                if (!highlighted) return true;
                const isDep = (c, t) => {
                    if (c.name === t) return true;
                    return c.refs.some(ref => {
                        const refNode = nodes.find(n => n.name === ref);
                        return refNode && isDep(refNode, t);
                    });
                };
                return isDep(highlighted, node.name) || isDep(node, highlightedNode);
            };

            return (
                <svg className="w-full h-full cursor-move"
                    onWheel={(e) => {
                        e.preventDefault();
                        const delta = e.deltaY > 0 ? 0.9 : 1.1;
                        setTransform(t => ({ ...t, scale: Math.max(0.1, Math.min(3, t.scale * delta)) }));
                    }}
                    onMouseDown={(e) => {
                        setIsDragging(true);
                        setDragStart({ x: e.clientX - transform.x, y: e.clientY - transform.y });
                    }}
                    onMouseMove={(e) => {
                        if (isDragging) {
                            setTransform(t => ({ ...t, x: e.clientX - dragStart.x, y: e.clientY - dragStart.y }));
                        }
                    }}
                    onMouseUp={() => setIsDragging(false)}
                    onMouseLeave={() => setIsDragging(false)}>
                    <g transform={`translate(${transform.x},${transform.y}) scale(${transform.scale})`}>
                        {edges.map((edge, i) => {
                            const h = isHighlighted(edge.source) && isHighlighted(edge.target);
                            return <line key={i} x1={edge.target.x} y1={edge.target.y} x2={edge.source.x} y2={edge.source.y}
                                stroke={h ? '#94a3b8' : '#e2e8f0'} strokeWidth={h ? 2 : 1} opacity={h ? 0.6 : 0.3} />;
                        })}
                        {nodes.map(node => {
                            const h = isHighlighted(node);
                            return (
                                <g key={node.name} transform={`translate(${node.x},${node.y})`}>
                                    <circle r={8} fill={DEPTH_COLORS[node.depth % DEPTH_COLORS.length]}
                                        opacity={h ? 1 : 0.3} onClick={() => onNodeClick(node.name)}
                                        className="cursor-pointer hover:opacity-100" />
                                    <text x={13} y={4} fontSize="12" fill={h ? '#1e293b' : '#94a3b8'}
                                        className="pointer-events-none select-none">{node.name}</text>
                                </g>
                            );
                        })}
                    </g>
                </svg>
            );
        }

        function SankeyView({ tokens, onNodeClick, highlightedNode, filter }) {
            const [transform, setTransform] = useState({ x: 0, y: 0, scale: 1 });
            const [isDragging, setIsDragging] = useState(false);
            const [dragStart, setDragStart] = useState({ x: 0, y: 0 });

            const filteredTokens = tokens.filter(t => !filter || t.type === filter);
            const byDepth = {};
            filteredTokens.forEach(token => {
                if (!byDepth[token.depth]) byDepth[token.depth] = [];
                byDepth[token.depth].push(token);
            });
            
            const nodes = [];
            Object.keys(byDepth).sort((a, b) => a - b).forEach(depth => {
                let yOffset = 50;
                byDepth[depth].forEach(token => {
                    nodes.push({ ...token, x: parseInt(depth) * 250 + 50, y: yOffset, height: 40 });
                    yOffset += 50;
                });
            });
            
            const links = [];
            nodes.forEach(node => {
                node.refs.forEach(refName => {
                    const target = nodes.find(n => n.name === refName);
                    if (target) links.push({ source: node, target });
                });
            });

            const isHighlighted = (node) => {
                if (!highlightedNode) return true;
                if (node.name === highlightedNode) return true;
                const highlighted = nodes.find(n => n.name === highlightedNode);
                if (!highlighted) return true;
                const isDep = (c, t) => {
                    if (c.name === t) return true;
                    return c.refs.some(ref => {
                        const refNode = nodes.find(n => n.name === ref);
                        return refNode && isDep(refNode, t);
                    });
                };
                return isDep(highlighted, node.name) || isDep(node, highlightedNode);
            };

            return (
                <svg className="w-full h-full cursor-move"
                    onWheel={(e) => {
                        e.preventDefault();
                        const delta = e.deltaY > 0 ? 0.9 : 1.1;
                        setTransform(t => ({ ...t, scale: Math.max(0.1, Math.min(3, t.scale * delta)) }));
                    }}
                    onMouseDown={(e) => {
                        setIsDragging(true);
                        setDragStart({ x: e.clientX - transform.x, y: e.clientY - transform.y });
                    }}
                    onMouseMove={(e) => {
                        if (isDragging) {
                            setTransform(t => ({ ...t, x: e.clientX - dragStart.x, y: e.clientY - dragStart.y }));
                        }
                    }}
                    onMouseUp={() => setIsDragging(false)}
                    onMouseLeave={() => setIsDragging(false)}>
                    <g transform={`translate(${transform.x},${transform.y}) scale(${transform.scale})`}>
                        {links.map((link, i) => {
                            const h = isHighlighted(link.source) && isHighlighted(link.target);
                            const sx = link.source.x + 200, sy = link.source.y + 20;
                            const tx = link.target.x, ty = link.target.y + 20;
                            const mx = (sx + tx) / 2;
                            return <path key={i} d={`M ${sx} ${sy} C ${mx} ${sy}, ${mx} ${ty}, ${tx} ${ty}`}
                                stroke={h ? DEPTH_COLORS[link.target.depth % DEPTH_COLORS.length] : '#e2e8f0'}
                                strokeWidth={4} fill="none" opacity={h ? 0.5 : 0.2} />;
                        })}
                        {nodes.map(node => {
                            const h = isHighlighted(node);
                            return (
                                <g key={node.name}>
                                    <rect x={node.x} y={node.y} width={200} height={40}
                                        fill={DEPTH_COLORS[node.depth % DEPTH_COLORS.length]}
                                        opacity={h ? 0.9 : 0.3} rx={4}
                                        onClick={() => onNodeClick(node.name)}
                                        className="cursor-pointer hover:opacity-100" />
                                    <text x={node.x + 10} y={node.y + 24} fontSize="12" fill="white"
                                        className="pointer-events-none select-none font-medium">{node.name}</text>
                                </g>
                            );
                        })}
                    </g>
                </svg>
            );
        }

        function ForceView({ tokens, onNodeClick, highlightedNode, filter }) {
            const [nodes, setNodes] = useState([]);
            const [transform, setTransform] = useState({ x: 0, y: 0, scale: 1 });
            const [isDragging, setIsDragging] = useState(false);
            const [dragStart, setDragStart] = useState({ x: 0, y: 0 });

            const filteredTokens = tokens.filter(t => !filter || t.type === filter);

            useEffect(() => {
                const init = filteredTokens.map((token) => ({
                    ...token, x: 600 + Math.random() * 200 - 100, y: 400 + Math.random() * 200 - 100, vx: 0, vy: 0
                }));
                setNodes(init);
                
                const links = [];
                init.forEach(node => {
                    node.refs.forEach(refName => {
                        const target = init.find(n => n.name === refName);
                        if (target) links.push({ source: node, target });
                    });
                });
                
                let animId;
                const sim = () => {
                    setNodes(curr => {
                        const n = curr.map(x => ({ ...x }));
                        for (let i = 0; i < n.length; i++) {
                            for (let j = i + 1; j < n.length; j++) {
                                const dx = n[j].x - n[i].x, dy = n[j].y - n[i].y;
                                const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                                const force = 2000 / (dist * dist);
                                n[i].vx -= (dx / dist) * force;
                                n[i].vy -= (dy / dist) * force;
                                n[j].vx += (dx / dist) * force;
                                n[j].vy += (dy / dist) * force;
                            }
                        }
                        links.forEach(link => {
                            const s = n.find(x => x.name === link.source.name);
                            const t = n.find(x => x.name === link.target.name);
                            if (s && t) {
                                const dx = t.x - s.x, dy = t.y - s.y;
                                const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                                const force = dist * 0.01;
                                s.vx += (dx / dist) * force;
                                s.vy += (dy / dist) * force;
                                t.vx -= (dx / dist) * force;
                                t.vy -= (dy / dist) * force;
                            }
                        });
                        n.forEach(node => {
                            node.vx *= 0.9;
                            node.vy *= 0.9;
                            node.x += node.vx;
                            node.y += node.vy;
                        });
                        return n;
                    });
                    animId = requestAnimationFrame(sim);
                };
                sim();
                return () => { if (animId) cancelAnimationFrame(animId); };
            }, [filteredTokens]);

            const links = [];
            nodes.forEach(node => {
                node.refs.forEach(refName => {
                    const target = nodes.find(n => n.name === refName);
                    if (target) links.push({ source: node, target });
                });
            });

            const isHighlighted = (node) => {
                if (!highlightedNode) return true;
                if (node.name === highlightedNode) return true;
                const highlighted = nodes.find(n => n.name === highlightedNode);
                if (!highlighted) return true;
                const isDep = (c, t) => {
                    if (c.name === t) return true;
                    return c.refs.some(ref => {
                        const refNode = nodes.find(n => n.name === ref);
                        return refNode && isDep(refNode, t);
                    });
                };
                return isDep(highlighted, node.name) || isDep(node, highlightedNode);
            };

            return (
                <svg className="w-full h-full cursor-move"
                    onWheel={(e) => {
                        e.preventDefault();
                        const delta = e.deltaY > 0 ? 0.9 : 1.1;
                        setTransform(t => ({ ...t, scale: Math.max(0.1, Math.min(3, t.scale * delta)) }));
                    }}
                    onMouseDown={(e) => {
                        setIsDragging(true);
                        setDragStart({ x: e.clientX - transform.x, y: e.clientY - transform.y });
                    }}
                    onMouseMove={(e) => {
                        if (isDragging) {
                            setTransform(t => ({ ...t, x: e.clientX - dragStart.x, y: e.clientY - dragStart.y }));
                        }
                    }}
                    onMouseUp={() => setIsDragging(false)}
                    onMouseLeave={() => setIsDragging(false)}>
                    <g transform={`translate(${transform.x},${transform.y}) scale(${transform.scale})`}>
                        {links.map((link, i) => {
                            const h = isHighlighted(link.source) && isHighlighted(link.target);
                            return <line key={i} x1={link.source.x} y1={link.source.y} x2={link.target.x} y2={link.target.y}
                                stroke={h ? '#94a3b8' : '#e2e8f0'} strokeWidth={h ? 2 : 1} opacity={h ? 0.6 : 0.3} />;
                        })}
                        {nodes.map(node => {
                            const h = isHighlighted(node);
                            return (
                                <g key={node.name} transform={`translate(${node.x},${node.y})`}>
                                    <circle r={10} fill={DEPTH_COLORS[node.depth % DEPTH_COLORS.length]}
                                        opacity={h ? 1 : 0.3} onClick={() => onNodeClick(node.name)}
                                        className="cursor-pointer hover:opacity-100" />
                                    <text x={15} y={4} fontSize="12" fill={h ? '#1e293b' : '#94a3b8'}
                                        className="pointer-events-none select-none">{node.name}</text>
                                </g>
                            );
                        })}
                    </g>
                </svg>
            );
        }

        function App() {
            const [css, setCss] = useState(EXAMPLE_CSS);
            const [tokens, setTokens] = useState([]);
            const [view, setView] = useState('tree');
            const [search, setSearch] = useState('');
            const [highlighted, setHighlighted] = useState(null);
            const [filter, setFilter] = useState(null);
            const fileRef = useRef(null);

            useEffect(() => {
                if (css) setTokens(parseCSS(css));
            }, [css]);

            const filtered = tokens.filter(t => t.name.toLowerCase().includes(search.toLowerCase()));
            const types = [...new Set(tokens.map(t => t.type))];
            const maxDepth = Math.max(...tokens.map(t => t.depth), 0);

            return (
                <div className="h-screen flex flex-col bg-slate-50">
                    <div className="bg-white border-b border-slate-200 px-6 py-4">
                        <h1 className="text-2xl font-bold text-slate-900 mb-4">CSS Variable Inheritance Mapper</h1>
                        <div className="flex gap-4 mb-4">
                            <input type="file" ref={fileRef} onChange={(e) => {
                                const file = e.target.files[0];
                                if (file) {
                                    const reader = new FileReader();
                                    reader.onload = (e) => setCss(e.target.result);
                                    reader.readAsText(file);
                                }
                            }} accept=".css" className="hidden" />
                            <button onClick={() => fileRef.current?.click()}
                                className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700">
                                Upload CSS
                            </button>
                            <input type="text" placeholder="Search tokens..." value={search}
                                onChange={(e) => setSearch(e.target.value)}
                                className="flex-1 px-4 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500" />
                        </div>
                        <div className="flex gap-2 mb-2">
                            <button onClick={() => setView('tree')}
                                className={`px-4 py-2 rounded-lg ${view === 'tree' ? 'bg-blue-600 text-white' : 'bg-slate-200'}`}>
                                Tree
                            </button>
                            <button onClick={() => setView('sankey')}
                                className={`px-4 py-2 rounded-lg ${view === 'sankey' ? 'bg-blue-600 text-white' : 'bg-slate-200'}`}>
                                Sankey
                            </button>
                            <button onClick={() => setView('force')}
                                className={`px-4 py-2 rounded-lg ${view === 'force' ? 'bg-blue-600 text-white' : 'bg-slate-200'}`}>
                                Force
                            </button>
                        </div>
                        <div className="flex gap-2">
                            <span className="text-sm py-1">Filter:</span>
                            <button onClick={() => setFilter(null)}
                                className={`px-3 py-1 rounded text-sm ${!filter ? 'bg-slate-700 text-white' : 'bg-slate-200'}`}>
                                All
                            </button>
                            {types.map(type => (
                                <button key={type} onClick={() => setFilter(type)}
                                    className={`px-3 py-1 rounded text-sm capitalize ${filter === type ? 'bg-slate-700 text-white' : 'bg-slate-200'}`}>
                                    {type}
                                </button>
                            ))}
                        </div>
                    </div>
                    <div className="flex-1 flex overflow-hidden">
                        <div className="w-80 bg-white border-r p-4 overflow-y-auto">
                            <h2 className="font-semibold mb-2">Input CSS</h2>
                            <textarea value={css} onChange={(e) => setCss(e.target.value)}
                                className="w-full h-64 p-3 border rounded-lg font-mono text-sm resize-none focus:outline-none focus:ring-2 focus:ring-blue-500"
                                placeholder="Paste CSS here..." />
                            <div className="mt-6">
                                <h2 className="font-semibold mb-3">Stats</h2>
                                <div className="space-y-2 text-sm">
                                    <div className="flex justify-between">
                                        <span>Tokens:</span><span>{tokens.length}</span>
                                    </div>
                                    <div className="flex justify-between">
                                        <span>Max Depth:</span><span>{maxDepth}</span>
                                    </div>
                                </div>
                            </div>
                            <div className="mt-6">
                                <h2 className="font-semibold mb-3">Legend</h2>
                                {[...Array(Math.min(maxDepth + 1, 10))].map((_, i) => (
                                    <div key={i} className="flex items-center gap-2 text-sm mb-2">
                                        <div className="w-4 h-4 rounded-full" style={{ backgroundColor: DEPTH_COLORS[i] }} />
                                        <span>Depth {i} {i === 0 ? '(Primitives)' : ''}</span>
                                    </div>
                                ))}
                            </div>
                            {highlighted && (
                                <div className="mt-6">
                                    <h2 className="font-semibold mb-3">Selected</h2>
                                    <div className="bg-slate-50 p-3 rounded-lg text-sm">
                                        <div className="font-mono text-xs mb-2">{highlighted}</div>
                                        {(() => {
                                            const t = tokens.find(x => x.name === highlighted);
                                            return t ? (
                                                <>
                                                    <div className="mb-1"><span className="text-slate-600">Value:</span> {t.value}</div>
                                                    <div className="mb-1"><span className="text-slate-600">Type:</span> {t.type}</div>
                                                    <div><span className="text-slate-600">Depth:</span> {t.depth}</div>
                                                </>
                                            ) : null;
                                        })()}
                                        <button onClick={() => setHighlighted(null)}
                                            className="mt-3 w-full px-3 py-1 bg-slate-200 rounded text-sm hover:bg-slate-300">
                                            Clear
                                        </button>
                                    </div>
                                </div>
                            )}
                        </div>
                        <div className="flex-1 bg-white relative">
                            {view === 'tree' && <TreeView tokens={filtered} onNodeClick={setHighlighted} highlightedNode={highlighted} filter={filter} />}
                            {view === 'sankey' && <SankeyView tokens={filtered} onNodeClick={setHighlighted} highlightedNode={highlighted} filter={filter} />}
                            {view === 'force' && <ForceView tokens={filtered} onNodeClick={setHighlighted} highlightedNode={highlighted} filter={filter} />}
                            <div className="absolute bottom-4 right-4 bg-white rounded-lg shadow-lg p-2 border text-xs text-slate-600">
                                Scroll to zoom â€¢ Drag to pan
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>